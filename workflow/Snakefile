# KAPy Workflow
#
# This snakemake workflow handles the processing of data for use
# in Klimaatlas-like products. 
#
# The pipeline can be run using
#    > snakemake --cores 1 <target>
#
# A list of available target rules can be obatined using
#   > snakemake -S
#
# Workflow configuration options are set in config.yaml
#
print("Processing KAPy snakefile...")

import KAPy
import os

#Setup-----------------------
#Load configuration 
configfile: "./config/config.yaml"  #Defined relative to execution directory
config=KAPy.validateConfig(config)
outDirs=config['dirs']


#Generate filename dicts
wf=KAPy.getWorkflow(config)

# Wildcard rules -------------------------------------------
# Wildcard rules are generic rules in Snakemake that deal with many files at a time -
# in KAPy we preface all such rules with an underscore "_" and a number indicating
# where in the processing chain their lie.
# The wf dict describes the nodes that are linked in the pipeline that we are
# trying to create, ie file c.nc is generated from files a.nc and b.nc. Here we
# translate that mapping into snakemake by declaring the code required to make
# that transformation. There is generally one "wildcard rule" for each of the
# main processing steps

#Primary variables
rule _01_primaryVar:
    input:
        lambda wildcards: wf['primVars'][wildcards.inpID][os.path.join(outDirs['primaryVariables'],
                                                                        wildcards.inpID,
                                                                        wildcards.outfile)]
    output:
        os.path.join(outDirs['primaryVariables'],"{inpID}","{outfile}")
    run:
        KAPy.buildPrimVar(outFile=output, 
                          inFiles=input,
                          picklePrimaryVariables=config['processing']['picklePrimaryVariables'],
                          cutoutArgs=config['cutouts'],
                          **config['inputs'][wildcards.inpID])

# Secondary variables 
# "Secondary variables" are calculated as new variables derived from primary variables.  
# Good examples include FWI, PoteEvap and SPI. 
rule _02_secondaryVar:
    input:
        unpack(lambda wildcards: wf['secondaryVars'][wildcards.secVarID][os.path.join(outDirs['secondaryVariables'],
                                                                        wildcards.secVarID,
                                                                        wildcards.outfile)])
    output:
        os.path.join(outDirs['secondaryVariables'],"{secVarID}","{outfile}")
    run:
        KAPy.buildDerivedVar(outFile=output,
                             inFiles=dict(input),
                             **config['secondaryVars'][wildcards.secVarID])

# Calibration 
# Aka bias-correction. 
rule _03_calibration:
    input:
        unpack(lambda wildcards: wf['calibratedVars'][wildcards.calID][os.path.join(outDirs['calibration'],
                                                                        wildcards.calID,
                                                                        wildcards.outfile)])
    output:
        os.path.join(outDirs['calibration'],"{calID}","{outfile}")
    run:
        KAPy.calibrate(outFile=output,
                        histsimFile=input.histsim,
                        refFile=input.ref,
                        tempDir=config['dirs']['tempDir'],
                        **config['calibration'][wildcards.calID])

# Tertiary variables 
# "Tertiary variables" are calculated as new variables derived from variables created
# by calibration. Good examples include FWI, PoteEvap and SPI, but based on calibrated
# variables, rather than raw input variables.
rule _04_tertiaryVar:
    input:
        unpack(lambda wildcards: wf['tertiaryVars'][wildcards.tertVarID][os.path.join(outDirs['tertiaryVariables'],
                                                                        wildcards.tertVarID,
                                                                        wildcards.outfile)])
    output:
        os.path.join(outDirs['tertiaryVariables'],"{tertVarID}","{outfile}")
    run:
        KAPy.buildDerivedVar(outFile=output,
                             inFiles=dict(input),
                             **config['tertiaryVars'][wildcards.tertVarID])


# Indicators 
# Create a loop over the indicators that defines the singular and plural rules
# as well as the combined run
rule _05_indicator:
    input:
        lambda wildcards: wf['indicators'][wildcards.indID][os.path.join(outDirs['indicators'],
                                                                        wildcards.indID,
                                                                        wildcards.outfile)]
    output:
        os.path.join(outDirs['indicators'],"{indID}","{outfile}")
    run:
        KAPy.calculateIndicators(outFile=output,
                                 inFile=input,
                                 seasonsTable=config['seasons'],
                                 periodsTable=config['periods'],
                                 **config['indicators'][wildcards.indID])

# Regridding  
# Combining everything into an ensemble requires that they are all on a common grid
# This step is optional but if the models are not on a common grid, this will cause failure 
# when we come to the ensstats generation
rule _06_regrid:
    input:
        lambda wildcards: wf['regridded'][os.path.join(outDirs['regridded'],
                                                       wildcards.thisID,
                                                       wildcards.outfile)]
    output:
        os.path.join(outDirs['regridded'],"{thisID}","{outfile}")
    run:
        KAPy.regrid(outFile=output,
                    inFile=input,
                    tempDir=config['dirs']['tempDir'],
                    templateType=config["outputGrid"]["templateType"],
                    path=config["outputGrid"]["path"],
                    method=config['outputGrid']['method'])


# Enssemble Statistics 
# Now we can combine them into ensembles
rule _07_ensstats:
    output:
        os.path.join(outDirs['ensstats'],"{es}")
    input:
        lambda wildcards: wf['ensstats'][os.path.join(outDirs['ensstats'],wildcards.es)]
    run:
        KAPy.generateEnsstats(outFile=output,
                              inFiles=input,
                              upperPercentile=config['ensembles']['upperPercentile'],
                              centralPercentile=config['ensembles']['centralPercentile'],
                              lowerPercentile=config['ensembles']['lowerPercentile'])

#Areal statistics
#Areal statistics are calculated for both the enssemble statistics and individual members
#Depending on whether we are using a shapefile or not, we may want to include the shapefile
#as a dependency
if config['arealstats']['shapefile']!='':
    rule _08_arealstats:
        output:
            os.path.join(outDirs['arealstats'],'{fname}')
        input:
            inputFile=lambda wildcards: wf['arealstats'][os.path.join(outDirs['arealstats'],
                                                            wildcards.fname)],
            shapefile=config['arealstats']['shapefile'] 
        run:
            KAPy.generateArealstats(outFile=output,
                                    inFile=input.inputFile,
                                    tempDir=config['dirs']['tempDir'],
                                    shapefile=input.shapefile,
                                    useAreaWeighting=config['arealstats']['useAreaWeighting'],
                                    idColumn=config['arealstats']['idColumn'])

else:  #No dependency on the shapefile
    rule _08_arealstats:
        output:
            os.path.join(outDirs['arealstats'],'{fname}')
        input:
            inputFile=lambda wildcards: wf['arealstats'][os.path.join(outDirs['arealstats'],
                                                            wildcards.fname)]
        run:
            KAPy.generateArealstats(outFile=output,
                                    inFile=input.inputFile,
                                    tempDir=config['dirs']['tempDir'],
                                    shapefile="",
                                    useAreaWeighting=config['arealstats']['useAreaWeighting'],
                                    idColumn=config['arealstats']['idColumn'])

#Plots        
rule _09_lineplots:
    output:
        os.path.join(outDirs['outputs'],'plots','{indID}_lineplot.png')
    input:
        lambda wildcards: wf['outputs'][os.path.join(outDirs['outputs'],'plots',
                                                   f"{wildcards.indID}_lineplot.png")]
    run:
        KAPy.makeLineplot(outFile=output,
                          srcFiles=input)

rule _09_boxplots:
    output:
        os.path.join(outDirs['outputs'],'plots','{indID}_boxplot.png')
    input:
        lambda wildcards: wf['plots'][os.path.join(outDirs['outputs'],'plots',
                                                   f"{wildcards.indID}_boxplot.png")]
    run:
        KAPy.makeBoxplot(outFile=output,
                         srcFiles=input)

rule _09_spatial_plots:
    output:
        os.path.join(outDirs['outputs'],'plots','{indID}_spatial.png')
    input:
        lambda wildcards: wf['plots'][os.path.join(outDirs['outputs'],'plots',
                                                   f"{wildcards.indID}_spatial.png")]
    run:
        KAPy.makeSpatialplot(outFile=output,
                             srcFiles=input)
        

# Individual targets -------------------------------
# These are individual files that are produced, rather than a collection of files

#Make the variable overview
rule overview:
    run:
        KAPy.VariableOverview(config)

#Merged csvs
rule merged_ensstats:
    output:
        os.path.join(outDirs['outputs'],config['outputs']["ensembleStatisticsCSV"])
    input:
        wf['mergedCSVs']['ensstats']
    run:
        KAPy.mergeCSVs(outFile=output,inFiles=input)

rule merged_members:
    output:
        os.path.join(outDirs['outputs'],config['outputs']["ensembleMembersCSV"])
    input:
        wf['mergedCSVs']['members']
    run:
        KAPy.mergeCSVs(outFile=output,inFiles=input)

# Database 
rule database:
    input:
        ensstats=rules.merged_ensstats.output,
        members=rules.merged_members.output
    output:
        os.path.join(outDirs['outputs'],config['outputs']["database"])
    run:
        KAPy.writeToDatabase(outFile=output,
                             ensstats=input.ensstats, 
                             members=input.members)

# Helper Targets ---------------------------------------------------------
# Here we define a series of short-hand targets that can be used to run 
# subsets of the full graph i.e. to make sets of files. This is not strictly
# necessary, but is a nice help for the user.

#Primary variables
rule primaryVars:
    input:
        [k for thisInp in wf['primVars'].values() for k in thisInp.keys()]

#Secondary variables  
rule secondaryVars:
    input:
        [k for thisInp in wf['secondaryVars'].values() for k in thisInp.keys()]

#Calibration
rule calibration:
    input:
        [k for thisInp in wf['calibratedVars'].values() for k in thisInp.keys()]

#Tertiary variables
rule tertiaryVars:
    input:
        [k for thisInp in wf['tertiaryVars'].values() for k in thisInp.keys()]

#Indicator variables
rule indicators:
    input:
        [k for thisInp in wf['indicators'].values() for k in thisInp.keys()]

#Regridding
if config['outputGrid']['templateType']!='none':
    rule regrid:
        input:
            list(wf['regridded'].keys())

#Ensemble statistics
rule ensstats:
    input:
        list(wf['ensstats'].keys())

#Plots
rule plots:
    input:
        list(wf['plots'].keys())

#All
rule all:
    input:
        wf['all'],
        rules.database.output
    default_target: True
